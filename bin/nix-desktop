#!/usr/bin/env bash

set -eou pipefail

err() { echo "$*" >&2; }

onAbort() { err "Aborted."; }
trap onAbort 1 2 6 15

########################
# Parsing command line #
########################

usage() {
  echo "Usage: $(basename $0) [install|uninstall|build] DIR"
}

showVersion() {
  echo "$(basename $0) VERSION"
}

if [[ $# -eq 0 ]]; then
  usage
  exit 2
fi

cmd=install

case "$1" in
  -h|--help)
    usage
    exit
    ;;
  --version)
    showVersion
    exit
    ;;
  build)
    cmd=build
    shift
    ;;
  install)
    cmd=install
    shift
    ;;
  uninstall)
    cmd=uninstall
    shift
    ;;
esac

if [[ $# -eq 1 ]]; then
  dir="$1"
else
  usage
  exit 2
fi

if ! [[ -d "$dir" ]]; then
  err "$dir is not an existing directory."
  exit 1
fi

#############
# Functions #
#############

compareAndInstall() {

  local destDir="$1"
  local relativeDir="$2"
  local updateHook="$3"

  local oldDir="$oldRoot/$relativeDir"
  local newDir="$newRoot/$relativeDir"

  local added=()
  local changed=()
  local deleted=()
  local notChanged=()

  declare -A newFiles=()
  declare -A oldFiles=()

  local updated=1

  if [[ -d "$newDir" ]]; then
    for filename in $(ls "$newDir"); do
      newFiles["$filename"]="$(readlink "$newDir/$filename")"
    done
  fi

  if [[ -d "$oldDir" ]]; then
    for filename in $(ls "$oldDir"); do
      oldFiles["$filename"]="$(readlink "$oldDir/$filename")"
    done
  fi

  for newFile in "${!newFiles[@]}"; do
    if [[ ! -d "$oldDir" ]] \
         || [[ ${#oldFiles[*]} -eq 0 ]] \
         || [[ ! ${oldFiles["$newFile"]+_} ]]; then
      added+=("$newFile")
    elif [[ ${oldFiles[$newFile]} = ${newFiles[$newFile]} ]]; then
      notChanged+=("$newFile")
    else
      changed+=("$newFile")
    fi
  done

  if [[ -v oldFiles ]]; then
    for oldFile in "${!oldFiles[@]}"; do
      if [[ ! ${newFiles["$oldFile"]+_} ]]; then
        deleted+=("$oldFile")
      fi
    done
  fi

  for filename in ${added[*]}; do
    echo "Added: $filename"
  done

  for filename in ${changed[*]}; do
    echo "Changed: $filename"
  done

  for filename in ${deleted[*]}; do
    echo "Deleted: $filename"
  done

  for filename in ${notChanged[*]}; do
    echo "Not changed: $filename"
  done

  # Check conflicts before actual operation
  for filename in ${added[*]}; do
    if [[ -e "$destDir/$filename" ]]; then
      err "$destDir/$filename already exists."
      return 1
    fi
  done
  for filename in ${changed[*]} ${notChanged[*]}; do
    if [[ -e "$destDir/$filename" ]]; then
      if [[ ! ${oldFiles["$filename"]+_} ]] \
           || [[ "$(readlink "$destDir/$filename")" != ${oldFiles["$filename"]} ]]; then
        err "$destDir/$filename does not point to an expected location."
        return 1
      fi
    fi
  done

  if [[ -x "$oldRoot/.pre-remove-hook" ]]; then
    for filename in ${deleted[*]}; do
      "$oldRoot/.pre-remove-hook" "$relativeDir" "$filename"
    done
  fi

  for filename in ${added[*]}; do
    mkdir -p "$destDir"
    ln -t "$destDir" -f -s "${newFiles[$filename]}"
    updated=0
    if [[ -x "$newRoot/.activate-on-add-hook" ]]; then
      activateHooks+=("$newRoot/.activate-on-add-hook $relativeDir $filename")
    fi
  done

  for filename in ${changed[*]}; do
    mkdir -p "$destDir"
    ln -t "$destDir" -fv -s "${newFiles[$filename]}"
    updated=0
    if [[ -x "$newRoot/.activate-on-change-hook" ]]; then
      activateHooks+=("$newRoot/.activate-on-change-hook $relativeDir $filename")
    fi
  done

  for filename in ${deleted[*]}; do
    unlink -v "$destDir/$filename"
    updated=0
  done

  # It would be better to always clear these non-local variables
  # declared inside a function.
  #
  # I've tried to make this unsetting as early as possible, but some
  # of the hooks above can fail, which can make the variables left
  # uncleared.
  unset newFiles
  unset oldFiles

  if [[ $updated -eq 0 ]]; then
    if [[ -n "$updateHook" ]]; then
      $updateHook
    fi
  fi

  # These hooks should be run after updating,
  # e.g. enable systemd services after reloading unit files

  if [[ -x "$newRoot/.post-add-hook" ]]; then
    for filename in ${added[*]}; do
      "$newRoot/.post-add-hook" "$relativeDir" "$filename"
    done
  fi

  # If necessary, implement post-change hook.
  # The implementation should be similar to post-add hook.
  #
  # if [[ -x "$oldRoot/.post-change-hook" ]]; then
  #   for filename in ${added[*]}; do
  #     "$oldRoot/.post-change-hook" "$relativeDir" "$filename"
  #   done
  # fi

}

uninstall() {
  local destDir="$1"
  local relativeDir="$2"
  local hook="$3"

  local oldDir="$oldRoot/$relativeDir"
  local dest
  local origin

  if ! [[ -d "$oldDir" ]]; then
    return
  fi

  for filename in $(ls "$oldDir"); do
    dest="$(readlink "$oldDir/$filename")"
    origin="$destDir/$filename"
    if [[ -L "$origin" ]] && [[ "$dest" = "$(readlink "$origin")" ]]; then
      echo "Removing $origin"
      unlink "$origin"
    fi
  done
}

group() {
  case "$cmd" in
    install)
      compareAndInstall "$@"
      ;;
    uninstall)
      uninstall "$@"
      ;;
  esac
}

########
# Main #
########

cd "$dir"
oldRoot=".nix-desktop-link"

case "$cmd" in
  install|build)
    newRoot="$(nix-build --arg configFile ./desktop.nix 'main.nix')"
    ;;
esac

if [[ "$cmd" = build ]]; then
  echo "$newRoot"
  exit
fi

# Run deactivate hooks.
# This actually calls pre-remove hook on each file.
if [[ "$cmd" = uninstall ]]; then
  if [[ -x "$oldRoot/.pre-remove-hook" ]]; then
    for dir in "share/systemd/user"; do
      for file in $(ls "$oldRoot/$dir"); do
        "$oldRoot/.pre-remove-hook" "$dir" "$file"
      done
    done
  fi
fi

declare -a activateHooks

group "${XDG_DATA_HOME:-$HOME/.local/share}/applications" \
      "share/applications" \
      "xdg-desktop-menu forceupdate"

group "${XDG_CONFIG_HOME:-$HOME/.config}/systemd/user" \
      "share/systemd/user" \
      "systemctl --user daemon-reload"

# Update the symlink
case "$cmd" in
  install)
    ln -sTf "$newRoot" "$oldRoot"
    ;;
  uninstall)
    if ! [[ -e "$oldRoot" ]]; then
      echo "Directory $oldRoot does not exist."
      echo "Nothing to do."
    else
      unlink "$oldRoot"
    fi
    ;;
esac

# Add activate hook Activation may fail, so it should be run
# after updating the state, i.e. the symbolic link.

# Some activate hooks may fail, while others may succeed. Thus the
# process should continue even an error occurs from one of the hook
# scripts. Use 'set +e' to permit error and use a variable to track
# the final exit code.
set +e
r=0
# TODO: Run activate hooks concurrently
if [[ -v activateHooks ]]; then
  for i in $(seq ${#activateHooks[*]}); do
    if ! ${activateHooks[$((i - 1))]}; then
      r=1
    fi
  done
fi
exit $r

# Local Variables:
# sh-basic-offset: 2
# End:
